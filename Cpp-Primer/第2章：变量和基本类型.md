## 第二章：变量和基本类型

### 2.1 基本内置类型

C++定义了一套**算术类型**和**空类型**在内的基本数据类型

#### 2.1.1 算术类型

当明确知道数值不可能为负时，选用无符号类型。

char在一些机器上是由符号的，在另一些机器上是无符号的，所以如果使用char进行运算容易出问题；如果需要使用一个不大的整数，那么明确指定它的类型是**signed char或者unsigned char**;

浮点运算选用double，float经常精度不够，并且计算代价相差无几；

#### 2.1.2 类型转换

切勿混用带符号类型和无符号类型；

#### 2.1.3 字面值常量

可以将整型字面值写作十进制数，八进制数和十六进制数；

**以0开头的整数代表八进制数，以0x或者0X开头的代表十六进制数；**

如：20（十进制） 022（八进制） 0x22（十六进制）

浮点型字面值表现为一个小数或以科学计数法表示的指数[指数部分由e或E标识]，默认是一个double；【3.14 3.141E	0.	0e0	.001】

由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符构成字符串型字面值；

字符串字面值的类型实际上是由常量字符构成的数组；编译器在每个字符串的结尾处添加一个空字符'\\0'，因此字面值的实际长度比它的内容多1。

**转义序列：**两类字符程序员不能直接使用：1.不可打印的字符 2.特殊含义的字符，所以需要转义字符

指定字面值的类型：

可以通过添加前缀或后缀，改完变整型、浮点型和字符型字面值的默认类型；

### 2.2 变量

#### 2.2.1 变量定义

类型说明符+一个或多个变量名组成的列表【变量名以逗号分隔】+分号；

如果是内置类型的变量违背显式初始化，它的值由定义的位置决定。

定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将**不被初始化**。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或者以其他形式访问此类值将引发错误；【我在codeblock测试的时候，*没有发现不被初始化导致的问题*，网上的案例与我实际跑的结果并不相同，可能是版本有变之类导致的】

#### 2.2.2 变量声明和定义的关系

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可以被独立编译；

如果将程序分为多个文件， 则需要有在文件间共享代码的方法。

为了支持分离式编译，C++语言将**声明和定义**区分开，**声明**使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明，而**定义**负责创建与名字关联的实体。

如果想声明一个变量而非定义它，就在变量前添加关键字extern；

```c++
extern int i;
```

任何包含了显示初始化的声明即成为定义。

```c++
extern int i = 1;
```



#### 2.2.3 标识符

变量名一般用小写；

用户自定义的类名一般以大写字母开头，如Sales_item；



#### 2.2.4 名字的作用域

作用域是程序的一部分，在其中名字有其特定的含义。C++中大多数作用域**以花括号分隔**；

**建议：当第一次使用变量时再定义它；**

```c++
int reused = 100;
int main{
	int reused = 0;
	std::cout<<reused<<endl;//访问的是main函数中的变量，输出0
	std::cout<<::reused<<endl;//显式地访问全局变量reused，输出100
	return 0;
}
```



### 2.3 复合类型

一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型；

#### 2.3.1 引用

C++11中新增了一种引用：“右值引用”，严格来说当我们使用术语引用的时候，指的是左值引用；

引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成 &+声明变量名 的形式来定义引用类型；

```c++
int val = 1024;
int &refVal = val;
int &refVal2 ;//wrong 引用必须初始化
```

定义引用的时候，将引用和它的初始值绑定在一起，而不是将初始值拷贝给引用；**引用必须初始化；**

引用就是别名；并非是一个对象，它只是一个已经存在的对象所起的另外一个名字；**引用只能绑定到一个对象上，而不能与字面值或者某个表达式的计算记过绑定在一起；**

#### 2.3.2 指针

指针是只想另外一种类型的复合类型。指针与引用相比不同点：**1.指针本身就是一个对象，允许对指针复制和拷贝，指针的生命周期内，它可以先后指向几个不同的对象；2.指针无须在定义时赋初值；**

指针存放的是某个对象的地址，要想获得该地址，需要使用**取地址符&**；

一般指针的类型要和它所指向的对象严格匹配；

指针值：

1. 指向一个对象；
2. 指向紧邻对象所占空间的下一个位置；//访问数组过程中的 ++
3. 空指针，意味着没有指向任何对象；
4. 无效指针；

**试图拷贝或以其他方式访问无效指针的值都将引发错误；编译器并不负责检查此类错误；**

```c++
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;//生成空指针的三种方式
```

在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL；

**建议：初始化所有指针**

Remember:赋值永远改变的是等号左侧的对象；

void* 指针：是一特殊的指针类型，可用于存放任意对象的地址，但是我们对于该地址中到底是个什么类型的对象并不了解；（void*的视角来看，内存空间也就是仅仅的内存空间，没办法访问内存空间中所存的对象）

#### 2.3.3 定义多个变量

```c++
int* p1, p2;//p1是指向int的指针，p2是int
```

指向指针的指针：

```c++
int ival = 1;
int *pi = &ival;
int **ppi = &pi;
```

指向指针的引用：引用本身不是一个对象，因此不能定义指向引用的指针，但是指针是对象，可以有对指针的引用；



面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义；

**离变量名最近的符号对变量的类型有最直接的影响；**



### 2.4 const限定符

用关键字const修饰常量；

 const对象必须初始化；

默认状态下，const对象仅在文件内有效；解决方案：extern关键字【不管是声明还是定义都添加】；

#### 2.4.1 const 的引用

可以把引用绑定到const上，称为对常量的引用；**对常量的引用不能被用作修改它所绑定的对象；**试图让一个非常量引用指向一个常量对象是错误的；

当一个常量引用被绑定到另外一种类型上时，如下：

```c++
double dval = 3.14;
const int &ri = dval;
```

为了确保ri绑定一个整数，编译器将以上代码改为如下形式；

```c++
double dval = 3.14;
const int temp = dval;
const int &ri = temp;
```

在这种情况下，ri绑定了一个临时量；



#### 2.4.2 指针和const

指向常量的指针不能用于改变其所指对象的值；**想要存放常量对象的地址，只能使用指向常量的指针；**

```c++
const double pi = 3.14;
double *ptr = &pi;//错误
const double *cptr = &pi;//正确
*cptr = 42;//错误
```

**常量指针必须初始化**，把*放在const关键字之前用以说明指针是一个常量，表示不变的是指针本身的值而非指向的那个值；

```c++
int errNumb = 0;
int *const curErr = &errNumb;
```



#### 2.4.3 顶层const

顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量；

```c++
int i = 0;
int *const p1 = &i;//不能改变p1的值，是一个顶层const
const int ci = 42;//不能改变ci的值，是一个顶层const
const int *p2 = &ci;//允许改变p2的值，是一个底层const
const int *const p3 = p2;//靠右的const是顶层const，靠左的是底层const
const int &r = ci;//用于声明引用的const都是底层const
```

当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转化；



#### 2.4.4 constexpr和常量表达式

常量表达式是指值不会改变并且在编译过程中就能得到结果的表达式；

constexpr变量：允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式；

**一般来说，如果你认定变量是一个常量表达式，那就把它声明为constexpr类型；**

常量表达式的值需要再编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。算术类型、引用、指针都属于字面值类型；

在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关；



### 2.5 处理类型

#### 2.5.1 类型别名

定义类型别名：typedef

```c++
typedef double wages;//wages是double的同义词
typedef wages base,*p;//base是double的同义词,p是double*的同义词
```

新标准规定了一种新的方法，使用别名声明来定义类型的别名；

```c++
using SI = Salse_items;
```

使用using关键字作为别名声明的开始，其后紧跟别名和等号，作用是把等号左侧的名字规定称等号右侧类型的别名；

```c++
typedef char *pstring;
const pstring cstr = 0;//cstr是指向char的常量指针
const pstring *ps;//ps是一个指针，他的对象是指向char的常量指针
```

一个错误理解：

```c++
const char *cstr = 0;//是对const pastring cstr的错误理解
```

声明语句中用到pstring时，其基本数据类型是指针；其声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针；

用char* 重写了声明语句之后，数据类型就变成了char，*成为了声明符的一部分。【就是说typedef不能直接替换再看含义】

#### 2.5.2 auto类型说明符

auto让编译器通过初始值来推算变量的类型；

```c++
// 由val1和val2相加的结果可以推断出item的类型
auto item = val1 + val2;//item初始化为val1和val2相加的结果
```

使用auto也能在一条语句中声明多个变量。因为一个声明语句只能有一个基本数据类型，所以该语句中所有变量的初始数据类型都必须一样；

```c++
auto i = 0, *p = &i;//正确，i是整数，p是整型指针
auto sz = 0, pi = 3.14;//错误，sz和pi的数据类型不一致
```

复合类型、常量和auto

编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当的改变结果类型使其更复合初始化规则。

引用其实是引用对象的值，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型；

```c++
int i = 0, &r = i;
auto a = r;//a是一个整数，（r是i的别名，而i是一个整数）
```

其次，auto一般会忽略掉顶层const，同时底层const则会保留下来；

```c++
const int ci = i, &cr = ci;
auto b = ci;//  一个整数（ci的顶层const特性被忽略掉了）
auto c = cr;//  一个整数（cr是ci的别名，ci本身是一个顶层const）
auto d = &i;//  整型指针（整数的地址就是指向整数的指针）
auto e = &ci;// 指向整数常量的指针（对常量对象取地址是一种底层const）
```

如果希望推断出的auto类型是一个顶层const，需要明确指出：

```c++
const auto f = ci;
```

#### 2.5.3 decltype 类型指示符

希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量；于是新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型；在此过程中，编译器分析表达式并得到它的类型，却不计算表达式的值；

```c++
decltype(f()) sum = x;//sum的类型就是函数f的返回类型；
```

decltype 处理顶层const和引用的方式和auto有所**不同**。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（**包括顶层const和引用在内**）；

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;//x的类型是const int
decltype(cj) y = x;//y的类型是const int&，y绑定到变量x
decltype(cj) z;//错误，z是一个引用，必须初始化
```

decltype 和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型；

对于decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果delctype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。

```c++
decltype(i) e;//正确，e是一个（未初始化的）int
decltype((i)) d;//错误，d是int&，必须初始化
```

切记：decltype((variable))的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用；

习题中的知识点：

赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型；也就是说，如果i是int，则表达式则表达式i=x的类型是int&。



### 2.6 自定义数据结构

#### 2.6.1 定义Sales_data类型

```c++
struct Sales_data{
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = .0;
};
```

类体右侧的表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义；

```c++
struct Sales_data{/* ... */ } accum, trans, *salesptr;
//等价于
struct Sales_data{/* ... */ } ;
Sales_data accum, trans, *salesptr;
```

####  2.6.2 Sales_data类的使用

#### 2.6.3 编写自己的头文件

为了确保各个文件中的类定义一致，类通常被定义在头文件中，而且类所在的头文件的名字应与类的名字一样。

头文件通常包含那些只能被定义一次的实体。头文件也经常用到其他头文件的功能。有必要在书写头文件时做适当处理，使其遇到多次包含的情况也能安全和正常的工作；

确保头文件多次包含仍能安全工作的常用技术是预处理器；

预处理器看到#include标记时就会用指定的头文件的内容代替#include；

**头文件保护符**：头文件保护符依赖于预处理变量；

预处理变量有两种状态：已定义和未定义。

**#define**指令把一个名字设定为预处理变量,**#ifdef**当且仅当变量已定义为真，**#ifndef**当且仅当比那辆未定义时为真。一旦检查结果为真，则执行后续操作直至遇到**#endif**;

使用这些功能就可以防止重复包含的发生；

```c++
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data{
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = .0;
};
#endif
```

预处理变量包括文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保唯一性；为了防止冲突，一般把预处理变量的名字全部大写；
