# 第13章：拷贝控制

一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。

### 13.1 拷贝、赋值和销毁

#### 13.1.1 拷贝构造函数

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。

```c++
class Foo {
public:
	Foo();
	Foo(const Foo&);//拷贝构造函数的第一个参数必须是一个引用类型
};
```

如果没有为一个类定义拷贝构造函数，编译器会为我们定义一个，即使定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。当使用拷贝初始化的时候，要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

拷贝初始化：

1. 用 = 定义变量
2. 将一个对象作为实参传递给一个非引用类型的形参
3. 从一个返回类型为非引用类型的函数返回一个对象
4. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

#### 13.1.2 拷贝赋值运算符

与类控制其对象如何初始化一样，类也可以控制其对象如何赋值：

```c++
Sales_data trans, accum ;
trans = accum;//拷贝赋值运算符
```

赋值运算符就是一个名为operator =  的函数，可以被重载。

#### 13.1.3 析构函数

```c++
class Foo {
public:
	~Foo();//析构函数
};
```

析构函数也有一个函数体和一个析构部分，由于析构函数不接受参数，因此它不能被重载。

一个对象被销毁，就会自动调用其析构函数：

1. 变量在离开其作用域时被销毁
2. 当一个对象被销毁时，其成员被销毁
3. 容器被销毁时，其元素被销毁
4. 动态分配的对象，当对指向它的指针应用delete运算符时被销毁
5. 对于临时对象，当创建它的完整表达式结束时被销毁

当一个类没有定义自己的析构函数时，编译器会为它定义一个合成析构函数。

#### 13.1.4 三/五法则

有三个基本操作可以控制类的拷贝操作：**拷贝构造函数，拷贝赋值运算符和析构函数**。

需要析构函数的类也需要拷贝和赋值操作；需要拷贝操作的类也需要赋值操作，反之亦然；

#### 13.1.5 使用 = default

可以通过将拷贝控制成员定义为 = default 来显式地要求编译器生成合成的版本；

#### 13.1.6 阻止拷贝

可以通过将拷贝函数和拷贝赋值运算符定义为删除的函数来阻止拷贝；

```c++
struct NoCopy {
	NoCopy() = default;
	NoCopy(const NoCopy&) = delete;//阻止拷贝
	NoCopy &operator=(const NoCopy&) = delete;//阻止赋值
    ~NoCopy() = default;
};
```

=delete必须出现在函数第一次声明的时候， =default 直到编译器生成代码时才需要。

析构函数不能删除，如果析构函数被删除，就无法销毁此类型的对象了（可以动态分配，但不能释放）。

合成的拷贝控制成员可能是删除的；

对某些类来说，编译器将这些合成的成员定义为删除的函数。规则是：如果**一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的**。

在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝；

### 13.2 拷贝控制和资源管理

类的行为像一个值，意味着它应该有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响；

行为像指针的类则共享状态，我们拷贝一个这种类的对象时，副本和原对象是完全独立的，改变副本也会改变原对象；

#### 13.2.1 定义行为像值的类

为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。

```c++
class HasPtr {
public:
	HasPtr(const std::string &s = std::string()): ps(new std::string(s)),i(0) {}
	HasPtr(const HasPtr &p): ps(new std::string(p->ps)),i(p.i) {}
    HasPtr operator=(cosnt HasPtr &);
    ~HasPtr(){ delete ps;}
private:
    std::string *ps;
    int i;
}
```

当编写复制运算符是，需要注意两点：

1. 如果将一个对象赋予它自身，赋值运算符必须能正确工作
2. 大多数赋值运算符组合了析构函数和拷贝构造函数的工作

当编写的时候，一个好的模式是：右侧运算对象拷贝到一个局部临时对象中，拷贝完成之后，销毁左侧运算对象的现有成员就是安全的了，之后可以再分配；

#### 13.2.2 定义行为像指针的类

对于行为类似指针的类，需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的对象。可以通过引用计数管理对象。

引用计数的工作方式如下：

- 除了初始化对象外，每个构造函数（除了拷贝构造函数）还要创建一个引用计数，用来记录多少对象与正在创建的对象共享，这个值初始化为1。
- 拷贝构造函数不分配新的技术其，而是拷贝给定对象的数据成员。
- 析构函数递减计数器，指出共享状态的用户少了一个，如果计数器变为0，析构寒假释放状态。
- 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。#左边指向另一个对象了

在哪里存放引用计数：

```C++
HasPtr p1("yy");
HasPtr p2(p1);
HasPtr p3(p1);
```

上面的程序中，如果将引用计数保存在每一个对象中，那么p2的技术并不会改变，是一种不合适的方法。

**一种方法**是：将计数器保存在动态内存中。当创建一个对象的时候，分配一个新的计数器。当拷贝或赋值对象的时候，我们拷贝指向计数器的指针。

```c++
class HasPtr {
public:
    HasPtr(const std::string &s = str::string()):
    	ps(new std::string(s)),i(0),use(new std::size_t(1)){}
    HasPtr(const HasPtr &p):
    	ps(p.ps), i(p.i), use(p.use){ ++*use; }
    HasPtr& operator = (const HasPtr&);
    ~HasPtr();
private:
    str::string *ps;
    int i;
    std::size_t *use;//共享的成员数目
}
```

赋值运算符必须处理自赋值，我们通过先递增rhs的计数再递减左边的计数来实现，可以防止两个对象相同时的问题；

```c++
HasPtr& HasPtr::operator-(const HasPtr &rhs){
    ++*rhs.use;
    if(--*use == 0){
        delete ps;
        delete use;
    }
    ps = rhs.ps;
    i = rhs.i;
    use = rhs.use;
    retrun *this;
}
```

### 13.3 交换操作

```c++
HasPtr temp = v1; 
v1 = v2;
v2 = temp;
```

上面的操作完成了swap的操作。理论上这些内存分配都是不必要的，我们更希望交换指针，而不是分配string的新副本，即：

```c++
string *temp = v1.ps;
v1.ps = v2.ps;
v2.ps = temp;
```

可以在我们的类上定义一个自己版本的swap来重载swap的默认行为；

```c++
class HasPtr{
	friend void swap(HasPtr&, HasPtr&);
};
inline void swap(HasPtr &lhs,HasPtr &rhs){
	using std::swap;
	swap(lhs.ps, rhs.ps);
	swap(lhs.i, rhs.i);
}
```

写完需要注意调用的时候不要用成标准库的swap；

定义swap的类通常用swap来定义它们的复制运算符，使用了一种名为拷贝并交换的技术。

```c++
//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数
HasPtr& HasPtr::operator=(HasPtr rhs)
{
	swap(*this,rhs);//rhs现在指向本对象曾经使用的内存
	return *this;//rhs被销毁，从而delete了rhs中的指针
}
```

指针指向副本然后返回这个。

### 13.5 动态内存管理

某些类需要自己进行内存分配，这些类一般必须定义自己的拷贝控制成员来管理所分配的内存；

**实现一个string的vector类的例子，被命名为StrVec。**

 vectorz的每个添加元素的成员函数会检查是否有空间容纳更多的元素，如果有...，如果没有就需要重新分配空间；使用allocator来获得原始内存；

每个StrVec有三个指针成员指向其元素使用的内存：

1. elements，指向首元素；
2. first_free，指向最后一个实际元素之后的位置；
3. cap，指向分配的内存末尾之后的位置；

StrVec还有一个名为alloc的静态成员，其类型为allocator\<string\>。alloc成员会分配StrVec使用的内存。还有四个工具函数：

1. alloc_n_copy，分配内存并拷贝一个给定范围中的元素；
2. free，销毁构造的元素并释放内存；
3. chk_n_alloc，保证StrVec至少有一个新元素的空间，如果没有就调用reallocate分配更多内存；
4. reallocate，在内存用完时为StrVec分配新内存；

**具体实现略。**

### 13.6 对象移动

在很多情况，对象拷贝后就立即被销毁了，这种情况下，移动而非拷贝对象会大幅提升性能；

在新标准下，可以用容器保存不可拷贝的对象，只要它们能被移动；

#### 13.6.1 右值引用

右值引用就是必须绑定到右值的引用，我们通过&&而不是&来获得右值引用。

左值持久，右值短暂；

由于右值引用只能绑定到临时对象，可知：

1. 所引用的对象将要被销毁
2. 该对象没有其他用户

这两个特性意味着：使用右值引用的代码可以自由接管所引用的对象的资源；

```c++
int &&rr1 = 42;//正确，字面常量是右值
int &&rr2 = rr1;//错误，表达式rr1是左值
```

虽然不能将一个右值引用直接绑定到一个左值上，但可以显式的将一个左值转换为对应的右值引用类型。可以通过对用一个名为move的新标准库函数来获得绑定到桌之上的右值引用；

```c++
int &&rr3 = std::move(rr1);// ok 
```

move调用告诉编译器：有一个左值，但希望像一个右值处理它。调用move意味着，除了对rr1赋值或销毁它外，我们将不再使用它。

#### 13.6.2 移动构造函数和移动赋值运算符

移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须由默认实参。除了完成资源移动，移动构造函数还必须确保移后源对象出于这样的状态——销毁它是无害的。一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象。

```c++
//实现一个StrVec到领一个StrVec的元素移动而非拷贝
StrVec::StrVec(StrVec && s) noexcept 
		: elements(s.elements),first_free(s.first_free),cap(s.cap)
{	
    //对s运行析构函数是安全的
	s.elements = s.first_free = s.cap = nullptr;		
}
```

移动操作通常不分配任何资源，因此不会抛出异常。

移动赋值运算符执行与析构函数和移动构造函数相同的工作，必须正确处理自赋值（用if判断即可）；

除了移后源对象必须可析构之外，移动操作必须保证对象仍然是有效的。指可以安全的使用而不依赖其他当前值，并且移动操作对移后源对象中留下的值没有任何要求。程序不应该依赖于移后源对象中的数据。

编译器会合成移动构造函数和移动赋值运算符，但不会为某些类合成移动操作：如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数**。**

**移动右值，拷贝左值**，如果一个类既有移动构造函数也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用那个构造函数。赋值的操作类似。**如果没有移动构造函数，右值也被拷贝。**

#### 13.6.3 右值引用和成员函数

除了构造函数和赋值运算符之外，如果一个成员函数同时提供拷贝和移动版本，它也能从中受益；

```c++
void push_back(const X&);//拷贝：绑定到任意类型的X
void push_back(X&&);//移动：只能绑定到类型X的可修改的右值
```

我们可以将能转换为类型X的任何对象传递给第一个版本的push_back。此版本从其参数拷贝数据。对于第二个版本，我们只可以传递给它非const的右值。

指出this的左值/右值属性的方式与定义const成员函数相同，即在参数列表后防止一个引用限定符。