## 第3章：字符串、向量和数组

### 3.1 命名空间的using声明

有了using声明就无须专门的前缀也可以使用所需的名字了

using声明具有如下形式：

```c++
using namespace::name;
```

头文件不应包含using声明：这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件都会有这个声明；

### 3.2 定义和初始化string对象

#### 3.2.1 定义和初始化string对象

常用的一些方式：

```c++
string s1;
string s2 = s1;
string s2(s1);
string s3 = "value";//s3是该字符串字面值的副本
string s3("value");
string s4(10,'c');//里面的内容是cccccccccc
```

直接初始化和拷贝初始化：

使用等号初始化一个变量，实际上执行的是拷贝初始化；如果不适用等号，则执行的是直接初始化；

#### 3.2.2 string对象上的操作

string 操作：

```c++
os<<s //将s写到输出流os当中，返回os
is>>s //从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is,s) //从is中读取一行赋给s，返回is
s.empty() //判断s是否为空
s.size() //返回s中的字符个数
s[n] //返回s第n个字符的引用
s1 + s2 //连接
s1 = s2 //赋值
s1 == s2 //判断两个字符内容是否一样
<, <=, >, >= //字典序比较
```

string::size_type类型

对于size函数来说，返回的是一个string::size_type类型的值（for 机器无关性）；

string::size_type是一个无符号类型的值，而且能足够存放下任何string对象的大小；

字面值和string对象相加

当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算法的两侧的运算对象至少有一个是string；**不能直接将字面值相加；**

#### 3.2.3 处理string对象中的字符

在cctype头文件中定义了一组标准库函数处理某个字符的特性；常用的：

```c++
#include<cctype>
isalpha(c);
isdigit(c);
islower(c);
isupper(c);
```

cctype头文件和ctype.h头文件的内容是一样的；

处理每个字符？使用基于范围的for语句

```c++
for(declaration : expression)
	statement
```

expression部分是一个对象，表示一个序列；declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。

```c++
string str("some string");
for(auto c : str)
	cout<< c <<endl;
```

for循环把变量c和str联系了起来，其中我们定义循环控制变量的方式与定义任意一个普通变量是一样的；

```c++
string s("Hello World!!!");//把小写字母变成大写字母
for(auto &c : s)
	c = toupper(c);
cout << s << endl;
```



### 3.3 标准库类型vector

标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。vector也被称为容器；

```c++
#include<vector>
vector<int> ivec;
vector<Sales_item> Sales_vec;
vector<vector<string> > file;
```

vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector；

#### 3.3.1 定义和初始化vector对象

```c++
vector<T> v1
vector<T> v2(v1) 			//包含v1所有元素的副本
vector<T> v2 = v1 			//等价于v2(v1)
vector<T> v3(n,val)			//包含n个重复元素，值都是val
vector<T> v4(n)				//包含了n个重复地执行了值初始化的对象
vector<T> v5{a,b,c...}		
vector<T> v5 = {a,b,c...}
```

列表初始值还是元素数量？

```c++
vector<int> v1(10); //10个元素
vector<int> v2{10}; //1个元素
vector<int> v3(10,1);//10个元素
vector<int> v4{10,1};//2个元素
```

如果用的是圆括号，可以说提供的值是用来构造vector对象的；

如果用的是花括号，可以表述成我们想列表初始化该vector对象；也就是说，**初始化的过程尽可能地把花括号内的值当成是元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式；**

```c++
vector<string> v5{"hi"};
vector<string> v6("hi");//错误
vector<string> v7{10};//十个空字符串
vector<string> v8{10,"hi"};//10个值为hi的字符串
```

#### 3.3.2 向vector对象中添加元素

利用vector的成员函数**push_back**向其中添加元素；

```c++
vector<int> v1;
for(int i = 0; i < 100 ;i++){
	v1.push_back(i);
}
```

关键概念：vector对象能高效增长；没必要设置大小，这样可能影响效率，但是要考虑更改过程中保证正确性；

#### 3.3.3 其他vector操作

```c++
v.empty()
v.size()
v.push_back(t)
v[n]
v1 = v2
v1 = {a,b,c...}
v1 == v2
<, <=, >, >= //以字典顺序进行比较
```

NOTE：要使用size_type，需首先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型；

```c++
vector<int>::size_type		//正确
vector::size_type			//错误
```

不能用下标形式添加元素：下标运算可以用于访问已存在的元素，而不能用于添加元素；

### 3.4 迭代器介绍 P121