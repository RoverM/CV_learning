## 第二章：变量和基本类型

### 2.1 基本内置类型

C++定义了一套**算术类型**和**空类型**在内的基本数据类型

#### 2.1.1 算术类型

![image-20211026151007360](https://github.com/RoverM/Cpp-Primer/tree/Cpp-Primer/Cpp-Primer/pic/image-20211026151007360.png)

当明确知道数值不可能为负时，选用无符号类型。

char在一些机器上是由符号的，在另一些机器上是无符号的，所以如果使用char进行运算容易出问题；如果需要使用一个不大的整数，那么明确指定它的类型是**signed char或者unsigned char**;

浮点运算选用double，float经常精度不够，并且计算代价相差无几；

#### 2.1.2 类型转换

切勿混用带符号类型和无符号类型；

#### 2.1.3 字面值常量

可以将整型字面值写作十进制数，八进制数和十六进制数；

**以0开头的整数代表八进制数，以0x或者0X开头的代表十六进制数；**

如：20（十进制） 022（八进制） 0x22（十六进制）

浮点型字面值表现为一个小数或以科学计数法表示的指数[指数部分由e或E标识]，默认是一个double；【3.14 3.141E	0.	0e0	.001】

由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符构成字符串型字面值；

字符串字面值的类型实际上是由常量字符构成的数组；编译器在每个字符串的结尾处添加一个空字符'\\0'，因此字面值的实际长度比它的内容多1。

**转义序列：**两类字符程序员不能直接使用：1.不可打印的字符 2.特殊含义的字符，所以需要转义字符

![image-20211026155333800](https://github.com/RoverM/Cpp-Primer/tree/Cpp-Primer/Cpp-Primer/pic/image-20211026155333800.png)

指定字面值的类型：

可以通过添加前缀或后缀，改完变整型、浮点型和字符型字面值的默认类型；

![image-20211026162153048](https://github.com/RoverM/Cpp-Primer/tree/Cpp-Primer/Cpp-Primer/pic/image-20211026162153048.png)

### 2.2 变量

#### 2.2.1 变量定义

类型说明符+一个或多个变量名组成的列表【变量名以逗号分隔】+分号；

如果是内置类型的变量违背显式初始化，它的值由定义的位置决定。

定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将**不被初始化**。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或者以其他形式访问此类值将引发错误；【我在codeblock测试的时候，*没有发现不被初始化导致的问题*，网上的案例与我实际跑的结果并不相同，可能是版本有变之类导致的】

#### 2.2.2 变量声明和定义的关系

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可以被独立编译；

如果将程序分为多个文件， 则需要有在文件间共享代码的方法。

为了支持分离式编译，C++语言将**声明和定义**区分开，**声明**使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明，而**定义**负责创建与名字关联的实体。

如果想声明一个变量而非定义它，就在变量前添加关键字extern；

```c++
extern int i;
```

任何包含了显示初始化的声明即成为定义。

```c++
extern int i = 1;
```

![image-20211026170437377](https://github.com/RoverM/Cpp-Primer/tree/Cpp-Primer/Cpp-Primer/pic/image-20211026170437377.png)

#### 2.2.3 标识符

变量名一般用小写；

用户自定义的类名一般以大写字母开头，如Sales_item；



#### 2.2.4 名字的作用域

作用域是程序的一部分，在其中名字有其特定的含义。C++中大多数作用域**以花括号分隔**；

**建议：当第一次使用变量时再定义它；**

```c++
int reused = 100;
int main{
	int reused = 0;
	std::cout<<reused<<endl;//访问的是main函数中的变量，输出0
	std::cout<<::reused<<endl;//显式地访问全局变量reused，输出100
	return 0;
}
```



### 2.3 复合类型

一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型；

#### 2.3.1 引用

C++11中新增了一种引用：“右值引用”，严格来说当我们使用术语引用的时候，指的是左值引用；

引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成 &+声明变量名 的形式来定义引用类型；

```c++
int val = 1024;
int &refVal = val;
int &refVal2 ;//wrong 引用必须初始化
```

定义引用的时候，将引用和它的初始值绑定在一起，而不是将初始值拷贝给引用；**引用必须初始化；**

引用就是别名；并非是一个对象，它只是一个已经存在的对象所起的另外一个名字；**引用只能绑定到一个对象上，而不能与字面值或者某个表达式的计算记过绑定在一起；**

#### 2.3.2 指针

指针是只想另外一种类型的复合类型。指针与引用相比不同点：**1.指针本身就是一个对象，允许对指针复制和拷贝，指针的生命周期内，它可以先后指向几个不同的对象；2.指针无须在定义时赋初值；**

指针存放的是某个对象的地址，要想获得该地址，需要使用**取地址符&**；

一般指针的类型要和它所指向的对象严格匹配；

指针值：

1. 指向一个对象；
2. 指向紧邻对象所占空间的下一个位置；//访问数组过程中的 ++
3. 空指针，意味着没有指向任何对象；
4. 无效指针；

**试图拷贝或以其他方式访问无效指针的值都将引发错误；编译器并不负责检查此类错误；**

```c++
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;//生成空指针的三种方式
```

在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL；

**建议：初始化所有指针**

Remember:赋值永远改变的是等号左侧的对象；

void* 指针：是一特殊的指针类型，可用于存放任意对象的地址，但是我们对于该地址中到底是个什么类型的对象并不了解；（void*的视角来看，内存空间也就是仅仅的内存空间，没办法访问内存空间中所存的对象）

#### 2.3.3 定义多个变量

```c++
int* p1, p2;//p1是指向int的指针，p2是int
```

指向指针的指针：

```c++
int ival = 1;
int *pi = &ival;
int **ppi = &pi;
```

指向指针的引用：引用本身不是一个对象，因此不能定义指向引用的指针，但是指针是对象，可以有对指针的引用；



面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义；

**离变量名最近的符号对变量的类型有最直接的影响；**



### 2.4 const限定符

用关键字const修饰常量；

 const对象必须初始化；

默认状态下，const对象仅在文件内有效；解决方案：extern关键字【不管是声明还是定义都添加】；

#### 2.4.1 const 的引用

可以把引用绑定到const上，称为对常量的引用；**对常量的引用不能被用作修改它所绑定的对象；**试图让一个非常量引用指向一个常量对象是错误的；

当一个常量引用被绑定到另外一种类型上时，如下：

```c++
double dval = 3.14;
const int &ri = dval;
```

为了确保ri绑定一个整数，编译器将以上代码改为如下形式；

```c++
double dval = 3.14;
const int temp = dval;
const int &ri = temp;
```

在这种情况下，ri绑定了一个临时量；



#### 2.4.2 指针和const

指向常量的指针不能用于改变其所指对象的值；**想要存放常量对象的地址，只能使用指向常量的指针；**

```c++
const double pi = 3.14;
double *ptr = &pi;//错误
const double *cptr = &pi;//正确
*cptr = 42;//错误
```

**常量指针必须初始化**，把*放在const关键字之前用以说明指针是一个常量，表示不变的是指针本身的值而非指向的那个值；

```c++
int errNumb = 0;
int *const curErr = &errNumb;
```



#### 2.4.3 顶层const

# 重新看 83 P57

顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量；

```c++
int i = 0;
int *const p1 = &i;//不能改变p1的值，是一个顶层const
const int ci = 42;//不能改变ci的值，是一个顶层const
const int *p2 = &ci;//允许改变p2的值，是一个底层const
const int *const p3 = p2;//靠右的const是顶层const，靠左的是底层const
const int &r = ci;//用于声明引用的const都是底层const
```

