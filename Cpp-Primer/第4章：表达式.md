# 第4章：表达式

表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。

### 4.1基础

#### 4.1.1 基本概念

c++定义了一元运算符和二元运算符。作用于一个运算对象的运算符是一元运算符，如取地址符&和解引用符*；作用于两个对象的为二元运算符，如相等==，乘法\*等；

c++定义了运算符作用于内置类型和符合类型的运算对象时所执行的操作，当运算符作用于类对象的时候，用户可以自定义其含义。称之为**重载运算符**。IO库的<< 和 >>以及string对象，vector对象h和迭代器使用的运算符都是重载的运算符。

**左值和右值**

C++的表达式是左值或者右值；一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。一个重要的原则：需要右值的地方可以用左值代替，但是不能把右值当成左值；当一个左值被当成右值使用的时候，实际使用的是它的内容；

- 赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也仍是一个左值；
- 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，是一个右值；
- 内置解引用、下标、迭代器解引用、string和vector的下标的求值结果都是左值；
- 内置类型和迭代器的递增递减运算符作用于左值运算对象，所得结果也是左值；

使用decltype的时候，左值和右值也有所不同。**如果表达式的求值结果是左值，decltype作用于该表达式得到一个引用类型；取地址运算符生成右值，所以decltype(&p)的结果是int\*\***

#### 4.1.2 优先级和结合率

#### 4.1.3 求值顺序

在大多数情况下，不会明确指定求值的顺序；

```c++
int i = f1() * f2();
```

f1()和f2()会在执行乘法之前被调用；但是无法得知f1和f2的执行顺序；

对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为，一个例子：

```c++
int i = 0 ;
cout << i << " " << ++i << endl;//错误，未定义的，但是运行了一下发现没有问题，是从左到右的一直
```

编译器可能先求++i的值，再求i的值，也可能先求i的值再求++i的值，甚至编译器还可能做完全不同的操作；因为表达式的行为不可预知，因此不论编译器生成什么样的代码都是错误的；

有4种运算符明确规定了运算对象的求值顺序 1. **&&**		2. **||**		3. **? :**		4. **,**

建议：处理复合表达式 1. 拿不准的时候用括号来强制表达式的顺序 2. 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象；2的一个例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效；

### 4.2 算术运算符 

###  4.3 逻辑和关系运算符

短路求值 && ， ||

```c++
if( i < j < k) //用 i < j的结果再与k计算
```

### 4.4 赋值运算符

```c++
int i = 0 , j = 1 , k = 2;//初始化而非赋值
const int ci = i; //初始化而非赋值
```

赋值满足右结合率；

```c++
int ival, jval;
ival = jval = 0; //正确，都被赋值为0
```

#### 4.5 递增和递减运算符

建议：除非必须，否则不用递增递降运算符的后置版本；

前置版本，将值+1之后，直接返回了改变的运算对象。后置版本需要将原始值存储下来以便于返回这个未修改的内容。（还有一些性能的考虑）

建议：简洁可以成为一种美德

```c++
cout << *iter << endl;
++iter;

cout << *iter++ << endl;//更推荐这种写法；
```




```c++
for(auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
	*it = toupper(*it);
	
while(beg != s.end() && !isspace(*beg))
    *beg = toupper(*beg++); // 错误，该赋值语句未定义；
```

问题在于：赋值运算符左右两端的运算对象都用到了beg，右边的运算对象改变了beg的值，所以该赋值语句是未定义的。编译器可能按照下面的任意一种思路处理该表达式；

```c++
*beg = toupper(*beg);		//如果先求左边的值
*(beg + 1) = toupper(*beg); //如果先求右边的值
```

也可能才去别的什么方式处理它；

### 4.6 成员访问运算符

ptr -> mem	等价于	(*ptr).mem	

### 4.7 条件运算符

?:

```c++
cond ? expr1 : expr2;//先求cond的值，如果为真，对expr1求值并返回该值，否则对expr2求值并返回该值；
```

```c++
cout << ((grade < 60) ? "fail" : "pass"); // 输出pass或者fail
cout << (grade < 60) ? "fail" : "pass"; // 输出0或1
cout << grade < 60 ? "fail" : "pass"; //错误，试图比较cout和60
```

### 4.8 位运算

```c++
~	求反
<<	左移	
>>	右移
&	与
^	异或
|	或
```

### 4.9 sizeof运算符

sizeof 运算符返回一条表达式或者一个类型名字所占的字节数

```c++
sizeof(type)
sizeof expr		//返回表达式结果类型的大小
```

可以利用sizeof的结果声明数组的维度；

```c++
constexpr size_t sz = sizeof(ia) / sizeof(*ia);
```

### 4.10 逗号运算符

首先对左侧的表达式求值，然后将求值的结果丢弃掉，逗号运算符真正的结果是右侧表达式的值；

```c++
int i, j;
j = 10;
i = (j++, j+100, 999+j);
cout << i << endl;//会输出1010
```

### 4.11 类型转换

何时发生隐式类型转换：

1. 比int类型小的整型首先提升为较大的整数类型
2. 非布尔值转换成布尔类型
3. 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
4. 如果算数运算或者关系运算的运算对象有多种类型，需要转换成同一种类型；
5. 函数调用也会发生类型转换；



无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的；

带符号类型大于无符号类型，转换结果依赖于机器；如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型，如果不能，那么带符号类型的运算对象转换成无符号类型；



其他隐式类型转换：

数组 -> 指针

指针转换：0转换成任意指针类型；指向任意非常量的指针能转换成void\*；指向任意对象的指针能转换成const void\*;

转换成布尔类型0和非0；

```c++
while(cin >> s) //将cin转转换为bool
```



命名的强制类型转换：

```c++
cast-name<type>(expression);
```

cast-name是static-cast，dynamic_cast【支持类型识别】，const_cast，reinterpret_cast中的一种；



**static_cast**

任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。

```c++
int i = 1 , j = 2;
double slope = static_cast<double>(j) / i ;
```

当需要把一个较大的算术类型赋值给较小的类型时，static_cast很有用。此时，强制类型转换告诉程序的读者和编译器，我们知道并且不在乎潜在的精度损失；

对于编译器无法自动执行的类型转换也非常有用，比如可以使用static_cast找回存在于void*中的值；

**const_cast**

const_cast只能改变运算对象的底层const：

```c++
const char *pc;
char *p = const_cast<char*>(pc);//正确，但是通过p写值是为定义的行为
```

对于将常量对象转化为非常量对象的行为，一般称其为去掉const性质。只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误，同样的，也不能用const_cast改变表达式的类型；

**reinterpret_cast**

通常为运算对象的为模式提供较低层次上的重新解释：

```c++
int *ip ;
char *pc = reinterpret<char*> (ip);
```

必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用可能在运行时发生错误；**使用reinterpret_cast是非常危险的；**

**建议：避免强制类型转换。**